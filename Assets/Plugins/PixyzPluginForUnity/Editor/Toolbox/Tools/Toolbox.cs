using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEditor;
using UnityEngine;
using Pixyz.Commons.Utilities;
using Pixyz.Plugin4Unity.Core;
using Pixyz.Commons.UI.Editor;

namespace Pixyz.Toolbox.Editor
{
    public static class Toolbox
    {
        public static bool Running = false;
        private const string TOOLBOX_AUTOGENERATED_MENUS_SCRIPT = "ToolboxMenuItems";
        private static Vector2 _LastMousePos;
        private static bool _MustShowMenu = false;

        [InitializeOnLoadMethod]
        private static void RegisterOnSceneGUI() {
#if UNITY_2019_1_OR_NEWER
            SceneView.duringSceneGui += (s) => OnSceneGUI();
#else
            SceneView.onSceneGUIDelegate += (s) => OnSceneGUI();
#endif
        }

        [MenuItem("Pixyz/Toolbox/⟳ Refresh", priority = 101)]
        public static void FillToolbox()
        {
            RefreshMenus();
        }

        [MenuItem("Pixyz/Toolbox/Create New Custom Action", priority = 100)]
        public static void CreateNewToolboxAction()
        {
            ToolsEditor.CreateNewAction(false, true);
        }

        [UnityEditor.Callbacks.DidReloadScripts]
        private static void OnScriptReload()
        {
            if (string.IsNullOrEmpty(GetToolboxIndexPath()))
            {
                RefreshMenus();
            }
        }

        public static void RefreshMenus() {

            string indexPath = GetToolboxIndexPath();

            if (string.IsNullOrEmpty(indexPath)) {
                // Script wasn't found. We make a new one from scratch.
                indexPath = Path.Combine(Preferences.ToolboxActionsLocation, TOOLBOX_AUTOGENERATED_MENUS_SCRIPT + ".cs"); 
                Directory.CreateDirectory(Path.GetDirectoryName(indexPath));

                string header = "using UnityEditor;\n" +
                    "namespace Pixyz.Toolbox.Editor {\n\n" +
                    "\t// THIS SCRIPT IS AUTOGENERATED. PLEASE DO NOT MODIFY OR MOVE IT.\n" +
                    "\tpublic static class " + TOOLBOX_AUTOGENERATED_MENUS_SCRIPT + " {\n\n";
                string footer = "\t}\n}";

                StringBuilder strbldr = new StringBuilder();

                //Regex regex = new Regex(@"[!""#$%&'()\*\+,\./:;<=>\?@\[\\\]^`{\|}~ ]");
                List<ActionBase> actions = GetToolboxActions();
                int maxOrder = actions.Max(a => a.order);
                foreach (var action in actions) {
                    string functionName = Guid.NewGuid().ToString();
                    functionName = functionName.Replace('-', '_');

                    if (action.menuPathToolbox == "Remove Hidden")
                    {
                        strbldr.Append("\t\t#if !UNITY_EDITOR_OSX\n");
                        strbldr.Append("\t\t[MenuItem(\"Pixyz/Toolbox/" + action.menuPathToolbox + "\", priority = 22)]\n");
                        strbldr.Append("\t\t[MenuItem(\"GameObject/Pixyz/" + action.menuPathToolbox + "\", priority = " + (action.order - maxOrder - 3) + ")]\n");
                        strbldr.Append("\t\tpublic static void A" + functionName + "() { Toolbox.RunToolboxAction(new " + action.GetType().FullName + "()); }\n");
                        strbldr.Append("\t\t#endif\n\n");
                    }
                    else
                    {
                        strbldr.Append("\t\t[MenuItem(\"Pixyz/Toolbox/" + action.menuPathToolbox + "\", priority = 22)]\n");
                        strbldr.Append("\t\t[MenuItem(\"GameObject/Pixyz/" + action.menuPathToolbox + "\", priority = " + (action.order - maxOrder - 3) + ")]\n");
                        strbldr.Append("\t\tpublic static void A" + functionName + "() { Toolbox.RunToolboxAction(new " + action.GetType().FullName + "()); }\n\n");
                    }

                }

                File.WriteAllText(indexPath, header + strbldr.ToString() + footer);
            } else {
                // Script was found. We delete it to ensure that there is no more compilation errors.
                if (!AssetDatabase.DeleteAsset(indexPath))
                    Debug.LogWarning("Could not remove asset at path : " + indexPath);
            }

            AssetDatabase.Refresh();
        }

        public static string GetToolboxIndexPath() {

            string[] paths = AssetDatabase.FindAssets(TOOLBOX_AUTOGENERATED_MENUS_SCRIPT);
            string path = null;
            if (paths.Length > 0) {
                path = AssetDatabase.GUIDToAssetPath(paths[0]);
            }

            if (!string.IsNullOrEmpty(path))
                return path;

            return null;
        }

        public static List<ActionBase> GetToolboxActions() {
            List<ActionBase> actions = new List<ActionBase>();
            foreach (var action in ToolsBase.GetAllActions().OrderBy(x => x.order)) {
                if (action.inputType == typeof(IList<GameObject>) && action.outputType == typeof(IList<GameObject>) && action.isInToolbox) {
                    actions.Add(action);
                }
            }
            return actions;
        }

        public static void RunToolboxAction(ActionBase action)
        {
            Dispatcher.StartCoroutine(RunToolboxActionAsync(action));
        }

        public static IEnumerator RunToolboxActionAsync(ActionBase action) {

            // This is quite hackish but otherwise Unity is sometimes triggering this multiple times at once.
            if (Running)
                yield break;

            Running = true;

            action.initialize();
            ToolboxWindow.ShowToolbox(action);

            yield return Dispatcher.GoMainThread();

            Running = false;
        }

        private static void OnSceneGUI()
        {

            if (!Preferences.RightClickInSceneForToolbox)
                return;

            Event evt = Event.current;

            if (evt.button != 1)
            {
                if (_MustShowMenu)
                {
                    _MustShowMenu = false;
                    ShowToolboxMenu();
                }
                return;
            }

            switch (evt.type)
            {
                case EventType.MouseDown:
                    _LastMousePos = evt.mousePosition;
                    break;

                case EventType.MouseUp:
                    float magnitude = (_LastMousePos - evt.mousePosition).magnitude;
                    if (magnitude < 3 && Selection.gameObjects.Length > 0)
                    {
                        _MustShowMenu = true;
                    }
                    break;
            }
        }

        private static void ShowToolboxMenu()
        {
            GenericMenu menu = new GenericMenu();
            menu.AddDisabledItem(new GUIContent("Pixyz"));
            menu.AddSeparator("");
            foreach (ActionBase action in GetToolboxActions())
            {
                if (action.inputType == typeof(IList<GameObject>) && action.outputType == typeof(IList<GameObject>) && action.isInToolbox)
                {
                    menu.AddItem(new GUIContent(action.menuPathToolbox, action.tooltip), false, new GenericMenu.MenuFunction(() => {
                        RunToolboxAction(action);
                    }));
                }
                else
                {
                    //menu.AddDisabledItem(new GUIContent(action.menuPathRuleEngine + " (" + GetFlowDisplayName(action.inputType) + ")", action.tooltip), false);
                }
            }
            menu.ShowAsContext();
        }
    }
}